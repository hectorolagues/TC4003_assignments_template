//********************************************************
//********************************************************
//*** Name: Hector Gabriel Olagues Torres
//*** UserID: hectorolagues
//*** Assignment 1-1, Q1 - Top K Words: intended to find
//*** the top K most common words in a text document.
//********************************************************
//********************************************************

package cos418_hw1_1

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"sort"
	"strings"
)

// Find the top K most common words in a text document.
// 	path: location of the document
//	numWords: number of words to return (i.e. k)
//	charThreshold: character threshold for whether a token qualifies as a word,
//		e.g. charThreshold = 5 means "apple" is a word but "pear" is not.
// Matching is case insensitive, e.g. "Orange" and "orange" is considered the same word.
// A word comprises alphanumeric characters only. All punctuations and other characters
// are removed, e.g. "don't" becomes "dont".
// You should use `checkError` to handle potential errors.
func topWords(path string, numWords int, charThreshold int) []WordCount {
	// Open the file stored in path and check for errors.
	file, err := os.Open(path)
	checkError(err)
	// Close the file when returning from this function, by using keyword defer.
	defer file.Close()
	
	// Parse the regular expression that returns alphanumeric characters only.
	rexp, err := regexp.Compile("[^0-9a-zA-Z]+")
	checkError(err)
	
	// Returns a map of the given type, initialized and ready for use, to map keys or words to values.
	counter := make(map[string]int)
	
	// Use a Scanner to implement a word-count utility by scanning the file as a sequence of space-delimited tokens.
	scanner := bufio.NewScanner(file)
	// Returns each space-separated word of text, with surrounding spaces deleted.
	scanner.Split(bufio.ScanWords)
	for scanner.Scan() {
		// Returns the most recent token generated by a call to Scan.
		word := scanner.Text()
		// Lower the case as the match is case insensitive.
		word = strings.ToLower(word)
		// Returns a copy of word, replacing matches of the RegExp as it is (no replacement string).
		word = rexp.ReplaceAllString(word, "")
		// Add a count to the word matching the key in the counter map if the length is greater or equal to threshold received as argument.
		if len(word) >= charThreshold {
			counter[word]++
		}
	}
	
	// Creates a slice of type WordCount struct
	var wordSlice []WordCount
	// Iterates over counter map and values returned are appended to wordSlice in the format of the struct.
	for key, value := range counter {
		wordSlice = append(wordSlice, WordCount{key, value})
	}
	sortWordCounts(wordSlice)
	
	// Return numWords once the slice is sorted
	return wordSlice[:numWords]
}

// A struct that represents how many times a word is observed in a document
type WordCount struct {
	Word  string
	Count int
}

func (wc WordCount) String() string {
	return fmt.Sprintf("%v: %v", wc.Word, wc.Count)
}

// Helper function to sort a list of word counts in place.
// This sorts by the count in decreasing order, breaking ties using the word.
// DO NOT MODIFY THIS FUNCTION!
func sortWordCounts(wordCounts []WordCount) {
	sort.Slice(wordCounts, func(i, j int) bool {
		wc1 := wordCounts[i]
		wc2 := wordCounts[j]
		if wc1.Count == wc2.Count {
			return wc1.Word < wc2.Word
		}
		return wc1.Count > wc2.Count
	})
}
